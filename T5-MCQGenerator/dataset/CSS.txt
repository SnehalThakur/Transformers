Today, we will look at the five most fundamental CSS concepts that every designer should know.
Whether you are aware or not, every composition is a hierarchy of some sort. Mentally acknowledging this hierarchy and then implementing it in your design helps structure information for the user — and keep your design tight and consistent.
Hierarchies consist of parents and children. Just like family trees, children can be parents to more children, and most parents are children themselves. In other words, you have ancestors: parents, grandparents, grand-grandparents, etc., and you have descendants: children, grandchildren, etcetera.
Think of your design as a collection of ancestors and descendants, with at the very top the design’s root: the canvas. If an ancestor moves, its descendants move too. If an ancestor changes dimensions, its children redistribute or resize too.
Every object in your design wants to have a defined personal space — or margin. Margin is the space an object wants to keep between itself and other objects, just like people prefer to keep a certain distance from other people in a crowded place.
Objects can have different margins for each of their sides. For example, a square may prefer to keep 100 pixels of space to its left but only 50 pixels of space to its top. A general rule of thumb is that objects with the same parent (siblings) all share the same set of margins. This helps a design look organized.
Changing an objects’ margin changes the distance between that object and other objects.
Closely related to margins, but fundamentally different is padding. Padding can be seen as fur: it’s an integral part of the object, not space around it. Just like margins, padding can have different values for top, left, right, and bottom.
Padding only comes into play when an object has children (or when an object has a predefined width or height, but let’s not complicate things). If a parent object has 20 pixels of padding and contains one child that is 100 pixels wide and 50 pixels high, the parent object will be 140 pixels wide and 90 pixels high because the fur is added to the dimensions of the parent.
Consistent use of padding helps to stabilize a design. If your design contains multiple types of containers (parents with children), even if they serve different purposes, it’s often best to use the same padding on each of those containers.
A container filled with children will grow as padding increases:
Containers can — and often do — have both padding and margins. The padding grows the actual dimensions of the container, the margin then defines the space between the container and other objects:
The distribution of objects in a static design is hardly an issue. But, user interfaces are seldom static. Instead of thinking about objects having a fixed position within their parent, it’s useful to think of their positions being governed by a certain logic. Flexboxes describe this logic.
The first thing to consider is how objects are going to be stacked within their parent. Generally, there are two options: you either stack them sideways (top to bottom or bottom to top) or vertically (left to right, or right to left).
In CSS, this is called the flex-direction property and accepted values are row | row-reverse | column | colum-reverse
Imagine you want to stack your objects from left to right, but the objects are either variable in height, or their parent is much taller than the children. In this case, you have to decide how to align them vertically, for which you will normally choose one of three options: start,center or end.The exact outcome of this value depends greatly on the direction you’ve chosen.
In CSS, this behavior is governed by the align-items property, and accepted values are flex-start | flex-end | center | stretch | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe.
Justification is very similar to alignment. However, where alignment concerns the position on the cross axis, justification governs the object position on the main axis. Put more simply: when using a left-to-right (horizontal) stack, alignment determines where your children go on the vertical axis, and justification concerns the horizontal distribution.
Here, too, we have the three usual suspects: start, center, and end.
Fortunately, there’s more to justification. This is where the logic of flexboxes really starts to shine.
It’s tempting to forego margins when you use flexboxes completely. However, when using flexboxes, margins of child objects are still taken into account. For example, in a left-to-right situation where the children are justified to the start of the flexbox, if the children have margins, there will be space between the children:
Lastly, there is the notion of absolute values versus relative values. In a design, an object can be 200 pixels wide, or 500, or 1171. But once this object is part of the actual user interface, how will it behave? Will it stretch? If yes, how wide may it be, at most? And when the viewport narrows, will the object get squished? How far will you allow it to be squished?

